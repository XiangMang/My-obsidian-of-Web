## 实验介绍

HI，各们小伙伴们，又见面了！😜 今天咱们这节讲点什么内容呢？嗯，今天讲点 "高大上" 的内容，我们知道，在前端在开发时，JavaScript 是一种依赖浏览器解析的语言，在访问文件时，需要依赖浏览器的兼容性，操作文件的能力很弱 ，而 `Node` 则这方面有很强的能力，那么，它是如何操作一个文件的呢？带着这个问题，我们快速地进入到今天的学习中来吧！

![图片描述](https://doc.shiyanlou.com/courses/uid1761387-20210917-1631830817091)

#### 知识点

- 文件读取操作
- 文件写入操作
- 删除文件操作

## 文件读取操作

在 `node` 中，如果要读取一个文件，就必须引入一个名称为 `fs` 的模块，而 `fs` 是 `file-system` 的简写，表示文件系统，在该模块中提供了全部操作文件的方法，因此，如果想去读取一个文件，必须先导入该模块，代码如下所示。

```js
const fs = require("fs");
```

完成模块导入之后，就可以使用该模块中读取文件的方法 `fs.readFile()` ，该方法是一个异步读取文件的方法，它的调用格式如下所示：

```js
fs.readFile(path[, options], callback)
```

在上述格式中，第一个参数 `path` 表示读取文件的路径，通常是一个相对路径，如"./public/msg.txt"，第二个参数 `options` 是一个可选项，在该项中可以设置读取文件时的编码格式 `encoding` ，文件打开的行为 `flag` ，允许中止正在进行的读取文件 `signal` ，其中 `flag` 包含多种方式，具体如下表所示：

| flag 名称 | 描述                                                         |
| --------- | ------------------------------------------------------------ |
| a         | 打开文件进行追加。 如果文件不存在，则创建该文件。            |
| ax        | 类似于 `a` 但如果路径存在则失败。                            |
| a+        | 打开文件进行读取和追加。 如果文件不存在，则创建该文件。      |
| ax+       | 类似于 `a+` 但如果路径存在则失败。                           |
| as        | 以同步模式打开文件进行追加。 如果文件不存在，则创建该文件。  |
| as+       | 以同步模式打开文件进行读取和追加。 如果文件不存在，则创建该文件。 |
| r         | 打开文件进行读取。 如果文件不存在，则会发生异常。            |
| r+        | 打开文件进行读写。 如果文件不存在，则会发生异常。            |
| rs+       | 以同步模式打开文件进行读写。 指示操作系统绕过本地文件系统缓存。 |
| w         | 打开文件进行写入。 如果它不存在则创建，如果它存在则截断该文件。 |
| wx        | 类似于 `w` 但如果路径存在则失败。                            |
| w+        | 打开文件进行读写。 如果它不存在则创建，如果它存在则截断该文件。 |
| wx+       | 类似于 `w+` 但如果路径存在则失败。                           |

第三个参数 `callback` 是一个回调函数， 在回调函数中，传入了两个参数，一个参数的名称为 `error` ，表示文件未读取成功时的错误信息，另一个参数的名称为 `data` ，表示文件读取成功时的内容信息，接下来通过一个示例来演示文件读取的过程。

找到并打开 `project` 文件夹，在该文件夹下，创建一个名称为 `public` 的文件夹，在 `public` 文件夹中，新建一个名称为 `msg` 的记事本文件，打开该文件，添加下列文字内容并保存。

```txt
蓝桥，一个学习知识的好地方！
          --程序员寄语--
```

再次找到并打开 `project` 文件夹，在该文件夹下，新建一个名称为 `readfile` 的 js 文件，打开该文件，并添加下列代码：

```js
// 导入 fs 模块
const fs = require("fs");

// 调用模块中异步读取文件的方法
fs.readFile("./public/msg.txt", "utf-8", (error, data) => {
  if (error) throw error;
  console.log(data);
});
```

在上述代码中，先导入 `fs` 模块，再调用模块中的异步读取文件的方法 `readFile` ，以 "utf-8" 的编码格式，读取记事本 `msg` 文件中的内容，在方法的回调函数中，如果出现错误，则返回相关的错误信息，如果没有出现错误，在控制台输出读取到的文件内容。最后，在 `project` 文件夹下，打开终端，并使用 `node` 执行名称为 `readfile` 的 js 文件，最终的效果如下图所示：

![图片描述](https://doc.shiyanlou.com/courses/4380/1761387/20b54ccc75f4bc67f319e0029e39543c-0)

从最终读取出的内容效果看，使用 `fs` 模块中的 `readFile` 方法，可以很方便地读取到文件中的内容，

## 文件写入操作

在 `fs` 模块中，与文件读取方法 `readFile` 相对应， `writeFile` 方法则是用于文件的写入，该方法也是一个异步写入文件的方法，它的调用格式如下所示：

```js
fs.writeFile(file, data[, options], callback)
```

在上述格式中，方法中第一个参数 `file` 表示要写入的文件名，第二个参数 `data` 表示需要写入的内容，第三个参数 `options` 是一个可选项，它与文件读取方法中的功能一样，在此不再赘述，第四个参数 `callback` 是一个回调函数， 在回调函数中，传入了一个名称为 `error` 的参数，表示文件没有写入成功时的错误信息，接下来通过一个示例来演示文件写入的过程。

找到并打开 `project` 文件夹，在该文件夹下，新建一个名称为 `writefile` 的 js 文件，打开该文件，并添加下列代码：

```js
// 导入 fs 模块
const fs = require("fs");

// 调用模块中异步写入文件的方法
fs.writeFile("./public/msg.txt", "今天是一个好日子", (error) => {
  if (error) throw error;
  console.log("写入成功！");
});
```

在上述代码中，先导入 `fs` 模块，再调用模块中的异步写入文件的方法 `writeFile`，将字符串"今天是一个好日子"写入 `msg` 文件中，由于该文件已存在，因此，写入的内容将会覆盖文件中原有的内容，同时，在方法的回调函数中，如果出现错误，则返回相关的错误信息，如果写入没有出错，则在控制台输出"写入成功！"的字样。最后，在 `project` 文件夹下，打开终端，并使用 `node` 执行名称为 `writefile` 的 js 文件，效果如下图所示：

![图片描述](https://doc.shiyanlou.com/courses/4380/1761387/19182ad77d7c247b2dfb174bdb3afbe6-0)

当调用 `fs` 模块中的 `writeFile` 方法在指定的文件中写入内容后，文件中的原有内容默认将会被覆盖，只保留最新写入的内容，也可以借助 `options` 对象中的 `flag` 属性值，改变写入文件时的方式，由覆盖变为追加内容，接下来通过一个示例来演示它实现的方式。

找到并打开 `project` 文件夹，在该文件夹下，新建一个名称为 `writefile2` 的 js 文件，打开该文件，并添加下列代码：

```js
// 导入 fs 模块
const fs = require("fs");

// 调用模块中异步写入文件的方法
fs.writeFile(
  "./public/msg.txt",
  "，明天又是一个大晴天。",
  { flag: "a", encoding: "utf-8" },
  (error) => {
    if (error) throw error;
    console.log("写入成功！");
  }
);
```

打开终端，并使用 `node` 执行名称为 `writefile2` 的 js 文件，效果如下图所示：

![图片描述](https://doc.shiyanlou.com/courses/4380/1761387/1f66e5636a2f6b4cbf467c6a959b7937-0)

在上述实现的代码中，`flag` 值为 "a" 时，表示以追加的方式向文件中写入内容，其他方式大家可以根据这种方式进行变更。

## 删除文件操作

在 `fs` 模块中，可以使用 `writeFile` 方法增加一个指定名称的文件，如果不希望使用某个文件，也可以调用 `unlink` 方法，删除这个文件， `unlink` 方法也是一个异步的方法，它的调用格式如下所示：

```js
fs.unlink(path, callback);
```

在上述格式中，第一个参数 `path` 表示删除文件的路径，第二个参数 `callback` 是一个回调函数， 在回调函数中，传入了一个名称为 `error` 的参数，表示文件没有删除成功时的错误信息，接下来通过一个示例来演示文件删除的过程。

首先找到并打开 `project` 文件夹，在该文件夹下，再打开 `public` 文件夹，新建一个文件为 `temp` 的记事本文件，结构如下图所示：

![图片描述](https://doc.shiyanlou.com/courses/4380/1761387/4abc8e01253fdefae3c891054d0ff01d-0)

最后，在 `project` 文件夹下，新建一个名称为 `delefile` 的 js 文件，打开该文件，并添加下列代码：

```js
// 导入 fs 模块
const fs = require("fs");

// 调用模块中异步删除文件的方法
fs.unlink("./public/temp.txt", (error) => {
  if (error) throw error;
  console.log("删除成功！");
});
```

在上述代码中，先导入 `fs` 模块，再调用模块中的异步删除文件的方法 `unlink` ，在方法的回调函数中，如果出现错误，则返回相关的错误信息，如果删除没有出错，则在控制台输出"删除成功！"的字样。最后，在 `project` 文件夹下，打开终端，并使用 `node` 执行名称为 `delefile` 的 js 文件，效果如下图所示：

![图片描述](https://doc.shiyanlou.com/courses/4380/1761387/038228b4b0cd09f2159976577a6d623d-0)

> 注意：在 `fs` 模块中的 `unlink` 方法，只能删除文件，不适用于删除目录，即使是一个空目录，如果要删除目录，需要使用另外一个名称为 `rmdir` 的方法，关于 `rmdir` 更的资料，请查看 👉 [rmdir 使用方法](http://nodejs.cn/api/fs.html#fs_fs_rmdir_path_options_callback)

## 实验总结

在本小节中，先介绍了如何在 `node` 中读取文件内容的方法，然后再介绍如何向文件中写入内容的过程，最后演示如何在 `node` 框架中去删除一个指定名称文件的方法。